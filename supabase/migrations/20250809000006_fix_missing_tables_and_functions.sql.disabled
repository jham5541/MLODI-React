-- Fix missing tables and add required functions

-- Create songs table if it doesn't exist
CREATE TABLE IF NOT EXISTS songs (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    title TEXT NOT NULL,
    artist_id UUID REFERENCES artists(id) ON DELETE CASCADE,
    album_id UUID REFERENCES albums(id) ON DELETE SET NULL,
    audio_url TEXT NOT NULL,
    cover_url TEXT,
    duration_ms INTEGER NOT NULL,
    genre TEXT,
    mood TEXT,
    tempo INTEGER,
    key_signature TEXT,
    lyrics TEXT,
    is_explicit BOOLEAN DEFAULT FALSE,
    is_public BOOLEAN DEFAULT TRUE,
    play_count INTEGER DEFAULT 0,
    like_count INTEGER DEFAULT 0,
    share_count INTEGER DEFAULT 0,
    nft_token_address TEXT,
    nft_total_supply INTEGER DEFAULT 0,
    nft_available_supply INTEGER DEFAULT 0,
    nft_price DECIMAL(20,8) DEFAULT 0,
    nft_royalty_percentage DECIMAL(5,2) DEFAULT 10.00,
    metadata JSONB DEFAULT '{}',
    waveform_data JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add is_private to playlists if it doesn't exist
DO $$ 
BEGIN 
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                  WHERE table_name='playlists' AND column_name='is_private') 
    THEN
        ALTER TABLE playlists ADD COLUMN is_private BOOLEAN DEFAULT FALSE;
    END IF;
END $$;

-- Create user_likes table if it doesn't exist
CREATE TABLE IF NOT EXISTS user_likes (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    liked_type TEXT CHECK (liked_type IN ('song', 'album', 'playlist')) NOT NULL,
    liked_id UUID NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, liked_type, liked_id)
);

-- Create play_history table if it doesn't exist
CREATE TABLE IF NOT EXISTS play_history (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    song_id UUID REFERENCES songs(id) ON DELETE CASCADE,
    played_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    duration_played_ms INTEGER DEFAULT 0,
    completion_percentage DECIMAL(5,2) DEFAULT 0,
    device_info JSONB DEFAULT '{}',
    location_info JSONB DEFAULT '{}'
);

-- Create engagements table if it doesn't exist
CREATE TABLE IF NOT EXISTS engagements (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    artist_id UUID REFERENCES artists(id) ON DELETE CASCADE,
    engagement_type TEXT NOT NULL,
    points INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create products and related tables if they don't exist
CREATE TABLE IF NOT EXISTS product_categories (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name TEXT NOT NULL,
    slug TEXT NOT NULL,
    description TEXT,
    icon TEXT,
    is_featured BOOLEAN DEFAULT false,
    sort_order INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS products (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    category_id UUID REFERENCES product_categories(id),
    artist_id UUID REFERENCES artists(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    price DECIMAL(10,2) NOT NULL,
    image_url TEXT,
    stock_quantity INTEGER DEFAULT 0,
    is_digital BOOLEAN DEFAULT FALSE,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS carts (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS cart_items (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    cart_id UUID REFERENCES carts(id) ON DELETE CASCADE,
    product_id UUID REFERENCES products(id) ON DELETE CASCADE,
    quantity INTEGER DEFAULT 1,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS orders (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    status TEXT DEFAULT 'pending',
    total_amount DECIMAL(10,2) NOT NULL,
    payment_intent_id TEXT,
    shipping_address JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create merchandise tables if they don't exist
CREATE TABLE IF NOT EXISTS merchandise (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    artist_id UUID REFERENCES artists(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    base_price DECIMAL(10,2) NOT NULL,
    image_url TEXT,
    is_available BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS merchandise_variants (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    merchandise_id UUID REFERENCES merchandise(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    price_adjustment DECIMAL(10,2) DEFAULT 0,
    stock_quantity INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create or replace get_top_performing_artists function
CREATE OR REPLACE FUNCTION get_top_performing_artists(
    limit_count INTEGER DEFAULT 10,
    top_percentage DECIMAL DEFAULT 0.1
)
RETURNS TABLE (
    artist_id UUID,
    artist_name TEXT,
    total_score BIGINT,
    ranking INTEGER
) 
LANGUAGE plpgsql
STABLE
AS $$
BEGIN
    RETURN QUERY
    WITH artist_scores AS (
        SELECT 
            a.id as artist_id,
            a.name as artist_name,
            COALESCE(SUM(fs.total_score), 0) as total_score,
            ROW_NUMBER() OVER (ORDER BY COALESCE(SUM(fs.total_score), 0) DESC) as ranking
        FROM artists a
        LEFT JOIN fan_scores fs ON a.id = fs.artist_id
        GROUP BY a.id, a.name
    )
    SELECT 
        as1.artist_id,
        as1.artist_name,
        as1.total_score,
        as1.ranking
    FROM artist_scores as1
    WHERE 
        as1.ranking <= limit_count
        OR as1.total_score >= (
            SELECT PERCENTILE_CONT(1 - top_percentage) 
            WITHIN GROUP (ORDER BY total_score)
            FROM artist_scores
        )
    ORDER BY as1.ranking
    LIMIT limit_count;
END;
$$;

-- Add missing indexes
CREATE INDEX IF NOT EXISTS idx_songs_artist_id ON songs(artist_id);
CREATE INDEX IF NOT EXISTS idx_songs_album_id ON songs(album_id);
CREATE INDEX IF NOT EXISTS idx_play_history_user_id ON play_history(user_id);
CREATE INDEX IF NOT EXISTS idx_play_history_song_id ON play_history(song_id);
CREATE INDEX IF NOT EXISTS idx_engagements_user_artist ON engagements(user_id, artist_id);
CREATE INDEX IF NOT EXISTS idx_products_artist_id ON products(artist_id);
CREATE INDEX IF NOT EXISTS idx_products_category ON products(category_id);
CREATE INDEX IF NOT EXISTS idx_cart_items_cart ON cart_items(cart_id);
CREATE INDEX IF NOT EXISTS idx_cart_items_product ON cart_items(product_id);
CREATE INDEX IF NOT EXISTS idx_orders_user ON orders(user_id);
CREATE INDEX IF NOT EXISTS idx_merchandise_artist ON merchandise(artist_id);
CREATE INDEX IF NOT EXISTS idx_merchandise_variants_merch ON merchandise_variants(merchandise_id);

-- Add RLS policies for new tables
ALTER TABLE songs ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE play_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE engagements ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE carts ENABLE ROW LEVEL SECURITY;
ALTER TABLE cart_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE merchandise ENABLE ROW LEVEL SECURITY;
ALTER TABLE merchandise_variants ENABLE ROW LEVEL SECURITY;

-- Basic RLS policies
CREATE POLICY "Users can view all songs" ON songs FOR SELECT TO authenticated USING (true);
CREATE POLICY "Users can like content" ON user_likes FOR ALL TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can view their play history" ON play_history FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can create play history" ON play_history FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can view all products" ON products FOR SELECT TO authenticated USING (true);
CREATE POLICY "Users can manage their cart" ON carts FOR ALL TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can manage their cart items" ON cart_items FOR ALL TO authenticated USING (
    cart_id IN (SELECT id FROM carts WHERE user_id = auth.uid())
);
CREATE POLICY "Users can view their orders" ON orders FOR SELECT TO authenticated USING (auth.uid() = user_id);
CREATE POLICY "Users can create orders" ON orders FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can view all merchandise" ON merchandise FOR SELECT TO authenticated USING (true);
CREATE POLICY "Users can view all merchandise variants" ON merchandise_variants FOR SELECT TO authenticated USING (true);

-- Triggers are managed in a separate migration

-- Sample data for product categories
INSERT INTO product_categories (name, slug, description) VALUES
    ('Merchandise', 'merchandise', 'Physical merchandise like t-shirts, posters, etc.'),
    ('Digital', 'digital', 'Digital content like downloads, NFTs, etc.'),
    ('Tickets', 'tickets', 'Event tickets and passes')
ON CONFLICT DO NOTHING;
